
```
/***************************************************************/
/*                                                             */
/*      PROJECT NAME :  RX220_test                             */
/*      FILE         :  RX220_test.c                           */
/*      DESCRIPTION  :  Main Program                           */
/*      CPU SERIES   :  RX200                                  */
/*      CPU TYPE     :  RX220                                  */
/*                                                             */
/*      This file is generated by e2 studio.                   */
/*                                                             */
/***************************************************************/                              

#include "iodefine.h"		//プログラムに必要なファイルを読み込む
#include "xprintf.h"

//LEDポート定義
#define	LED1		PORTA.PODR.BIT.B4
#define	LED2		PORTA.PODR.BIT.B1
#define	LED3		PORTA.PODR.BIT.B0
#define	LED4		PORTA.PODR.BIT.B3
#define	LED5		PORTA.PODR.BIT.B6

//SWポート定義
#define	SW_GREEN		PORT0.PIDR.BIT.B5

//LEDマクロ定義
#define	LED_ON		1
#define	LED_OFF		0

//SWマクロ定義
#define	SW_ON		0
#define	SW_OFF		1

//SCI通信ボーレート
#define	SCI_BITRATE	9600

//プロトタイプ宣言
void init_RX220(void);
void wait_sw_off(void);
void wait_ms(long ms);
void LED_num(char n);
void print_sci(unsigned char data);
void interrupt_1ms(void);
void uart_send_unsignedchar(unsigned char val);

//音声IC用関数
void play(unsigned char track);
void volume(unsigned char vol);

void main(void){		//一番最初に実行する関数
	init_RX220();		//初期設定関数

	short count = 0;
	LED_num(1);
	wait_ms(1000);
	LED_num(0);

	while(1){
		if(SW_GREEN == SW_ON){
			wait_sw_off();
			count++;
			LED_num(count);
			if(count > 15){count = 0;}
			volume(0x07); //Volume settings 0x00-0x1E
			play(0x01);
			//xprintf("up :%2d\n", count);
		}
	}

}
//---------------------------------------------------------------
//初期設定
//---------------------------------------------------------------
void init_RX220(void){
	//クロック設定
	SYSTEM.PRCR.WORD = 0xa50b;	//レジスタ書き込み許可
	SYSTEM.SCKCR3.BIT.CKSEL = 2;//クロックソースをメインクロック(20MHz)に設定
	SYSTEM.MOSCCR.BYTE = 0;		//メインクロック発振器動作
	for(volatile short i = 0; i < 300; i++);//クロックが安定するまで待つ

	//IOポート初期設定
	PORT.PSRA.BIT.PSEL6 = 0;	//PB6を選択
	PORT.PSRA.BIT.PSEL7 = 0;	//PB7を選択
	PORTA.PDR.BYTE = 0x5b;		//PA0,1,3,4,6(LED)を出力に設定(0101 1011)
	PORTA.PODR.BYTE = 0x00;		//PA0,1,3,4,6(LED)の出力を0にする(0000 0000)
	PORT0.PCR.BIT.B5 = 1;		//P05(タクトスイッチ)の内部プルアップを有効にする

	//コンペアマッチタイマ初期設定
	//1ms割り込み用
	MSTP_CMT0 = 0; 				//モジュールストップ解除
	CMT.CMSTR0.BIT.STR0 = 0;	//タイマ停止
	CMT0.CMCR.BIT.CKS = 1;		//動作周波数設定:20MHz／32 = 625kHz
	CMT0.CMCR.BIT.CMIE = 1;		//コンペアマッチで割り込みを許可
	CMT0.CMCNT = 0;				//カウントをクリア
	CMT0.CMCOR = 625-1;			//1ms周期で割り込み	割り込みが発生するのはコンペアマッチした次のカウントタイミングなので1を引く
	IR(CMT0,CMI0) = 0;			//割り込み要求フラグクリア
	IEN(CMT0,CMI0) = 1;			//割り込み要求許可
	IPR(CMT0,CMI0) = 1;			//割り込み優先度設定
	CMT.CMSTR0.BIT.STR0 = 1;	//タイマスタート

	//wait_ms関数用
	MSTP_CMT1 = 0; 				//モジュールストップ解除
	CMT.CMSTR0.BIT.STR1 = 0;	//タイマ停止
	CMT1.CMCR.BIT.CKS = 1;		//動作周波数設定:20MHz／32 = 625kHz

	//SCI初期設定
	unsigned short dummy;

	//別になくても動いた
	/*-------------------------*/
	//PORTB.PDR.BIT.B6=1;			//PB6を出力設定
	//PORTB.PDR.BIT.B7=1;			//PB7を出力設定
	//PORTB.ODR1.BIT.B4=1;		//PB6をオープンドレインに設定
	//PORTB.ODR1.BIT.B6=1;		//PB7をオープンドレインに設定
	/*-------------------------*/

	MSTP_SMCI9 = 0;				//SCI9モジュールスタンバイ解除
	SCI9.SCR.BYTE = 0x00;		//送信,受信及び割り込み要求を禁止
	MPC.PWPR.BIT.B0WI = 0;		//PFSWEビットへの書き込みを許可
	MPC.PWPR.BIT.PFSWE = 1;		//PFSレジスタへの書き込みを許可
	MPC.PB6PFS.BIT.PSEL = 10;	//PB6をRXD9に設定
	MPC.PB7PFS.BIT.PSEL = 10;	//PB7をTXD9に設定
	MPC.PWPR.BIT.PFSWE = 0;		//PFSレジスタへの書き込みを禁止
	MPC.PWPR.BIT.B0WI = 1;		//PFSWEビットへの書き込みを禁止
	PORTB.PMR.BIT.B6 = 1;		//TXD9を周辺モジュール入出力に設定
	PORTB.PMR.BIT.B7 = 1;		//RXD9を周辺モジュール入出力に設定
	SCI9.SCR.BIT.CKE = 0;		//クロック設定
	SCI9.SMR.BYTE = 0x00;		//b0 					0：
								//b1クロック選択ビット			0：PCLKクロック(n=0)
								//b2 マルチプロセッサモードビット	0：マルチプロセッサ通信機能を禁止
								//b3 ストップビット長選択		0：1ストップビット
								//b4 パリティモードビット			0：偶数パリティで送受信
								//b5 パリティ許可ビット			0：パリティビットを付加
								//b6 キャラクタ長ビット			0：データ長8ビットで送受信
								//b7 コミュニケーションモードビット	0：調歩同期式モードで動作

	//(CLOCK)/(64*SCI_BITRATE*2^(2n-1))-1
	long sci_brr;
	sci_brr = (20000000 * 10) / (64 * SCI_BITRATE / 2) - 10;
	sci_brr = (sci_brr + 5) / 10;

	SCI9.BRR = (unsigned char)sci_brr;	//ビットレート調整
	IPR(SCI9,TXI9) = 14;		//割り込み優先度設定
	IPR(SCI9,RXI9) = 14;		//割り込み優先度設定
	IR(SCI9,TXI9) = 0;			//割り込み要求フラグクリア
	IR(SCI9,RXI9) = 0;			//割り込み要求フラグクリア
	for(dummy = 0; dummy < 50000; dummy++);//ちょっと待つ
	SCI9.SCR.BIT.TIE = 1;		//TXI割り込み許可
	SCI9.SCR.BIT.RIE = 1;		//RXI割り込み許可
	SCI9.SCR.BIT.TE = 1;		//送信開始
	SCI9.SCR.BIT.RE = 1;		//受信開始
	dummy = SCI9.SSR.BYTE;		//ダミーリード
	SCI9.SSR.BYTE = 0xC0;		//フラグクリア

	xdev_out(print_sci);
}

//---------------------------------------------------------------
//wait処理
//---------------------------------------------------------------
//チャタリング防止処理
void wait_sw_off(void){
	wait_ms(50);	//50ms待つ
	//全てのスイッチがOFFになるまでループして待つ
	while(SW_GREEN == SW_ON);
	wait_ms(50);	//50ms待つ
}

//wait関数
//指定した時間[ms]待つ
void wait_ms(long ms){
	volatile unsigned long count;

	while(ms > 0){
		if(ms > 100){			//100msまでしか1度に計れない
			count = 100;
		}
		else{
			count = ms;
		}
		ms -= 100;
		count = count * 625 - 1;//625は1msあたりのカウント数
		CMT1.CMCNT = 0;
		CMT.CMSTR0.BIT.STR1 = 1;
		while(CMT1.CMCNT < count);
		CMT.CMSTR0.BIT.STR1 = 0;
	}
}

//---------------------------------------------------------------
//ユーザーインターフェース
//---------------------------------------------------------------
//整数を渡すと2進数をLEDで表示
void LED_num(char n){
	n &= 0x0f;

	if((n&0x08) == 0x08){LED1 = LED_ON;}
	else	{LED1 = LED_OFF;}
	if((n&0x04) == 0x04){LED2 = LED_ON;}
	else	{LED2 = LED_OFF;}
	if((n&0x02) == 0x02){LED3 = LED_ON;}
	else	{LED3 = LED_OFF;}
	if((n&0x01) == 0x01){LED4 = LED_ON;}
	else	{LED4 = LED_OFF;}
}

//音楽再生
void play(unsigned char track) {
	unsigned char play[6] = { 0xAA, 0x07, 0x02, 0x00, track, track + 0xB3 };
	for (int i = 0; i < 6; i++) {
		uart_send_unsignedchar(play[i]);
	}
}
void volume(unsigned char vol) {
	unsigned char volume[5] = { 0xAA, 0x13, 0x01, vol, vol + 0xBE };
	for (int i = 0; i < 6; i++) {
		uart_send_unsignedchar(volume[i]);
	}
}


//unsigned char型の文字をSCIで送る関数
void print_sci(unsigned char data){
	while(!IR(SCI9,TXI9));
	SCI9.TDR = data;			//データを転送
	IR(SCI9,TXI9) = 0;
}

//データを1バイトずつ送信する
void uart_send_unsignedchar(unsigned char val){
	while(!IR(SCI9,TXI9));
	SCI9.TDR = val;						//次に送信する文字をセット
	IR(SCI9,TXI9) = 0;
}


//---------------------------------------------------------------
//タイマ割り込み
//---------------------------------------------------------------
//1ms間隔で実行される関数
void interrupt_1ms(void){

}
```
