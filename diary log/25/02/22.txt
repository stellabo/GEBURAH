uart機能を使い、rx220⇔PS3間、サーボモーター間との接続にそれぞれ成功した。


課題：
・無線での書き込みと、PS3コントローラーとの接続機能を両立させることができない。
SBDBTに出荷時のファームウェアを書き込むと無線でも書き込みができるが、
PS3コントローラー用ファームウェアを書き込んだ場合、無線での書き込みができなくなる。
出荷時ファームウェアとPS3用ファームウェアの違いによるものと思われるが、
具体的にどの部分が関係しているかは分かっていない。
UARTの部分は問題がないことは分かってるので、UART→bluetoothの変換部分で問題が起こっていると思われる。
ランニングエレクトロニクスに問い合わせたところ、
・ACLペイロードサイズ　(Bluetoothのデータ転送で1パケットに含められるデータ量の上限?)
・rfcomm
の2つに違いがあるとのこと。(他にも違いはある。)
特に、ACLペイロードサイズはデータ転送に関係する部分のため、通信に影響を与えている可能性は高いが、
ペイロードサイズを高くすると、PS3関連に割くメモリが足りなくなる(?)らしく、
実際に変えると、PCがSBDBTを認識しなくなってしまったので、簡単に解決することは難しそう。
いずれは解決したいが、
暫定措置として、SBDBTと書き込み端子を分離or切り替え可能にする予定。

・UART接続の速さ
サーボモーターとの通信を行う際、uartの速度を115200bpsに設定していたが、
BRRレジスタの代入数値が間違っており、115200bpsで通信できていなかった。
オシロスコープを用いて波形を確認したが、BRRレジスタの値を小さくするほど、波形の幅が短くなることが分かった。
uartの速度が速いほど、サーボとの通信速度も速くなるが、uartがどの程度の速度まで通信可能かはマイコンの
動作周波数に依存していると思われる。
RX220の動作周波数は20MHzで設定しているが、BRRレジスタの計算式に代入すると、20MHzでは1.25MHzに対応できないと思われる。
RX220はPLL回路を搭載していないため、20MHzから周波数を逓倍することはできない。
よって、PLL回路を持つRX631であれば、1.25MHzのuart接続ができる可能性がある。
全てのサーボを独立してRCB-4に接続する分には、通信速度の恩恵を感じにくいが、
デイジーチェーンで複数のサーボを数珠つなぎにするほど、恩恵を感じやすいのではないかと思われる。

　UART通信にはクロック端子がありませんが、マイコンの内部クロックに同期しながら動作します（図1参照）。一般的に、「クロックの周波数誤差が2～3％ならUARTは通信可能」と言われています。マイコンの内蔵発振回路の周波数の誤差がこの範囲内であれば、使用できます。もし、マイコンにPLL（Phase Locked Loop）が搭載されていて、UARTのクロックにPLLの出力クロックが使用されていれば、PLLの周波数誤差を考慮する必要があります。
　また、UARTで通信する相手のデバイスのクロック周波数誤差も考慮しなければなりません。例えば、相手のデバイスの周波数誤差が2％以上あると、こちらのマイコンの誤差は1％以下にしないと、トータルの誤差が3％を超えるので、誤通信の原因になります。


ソースコード

/***************************************************************/
/*                                                             */
/*      PROJECT NAME :  RX220_test                             */
/*      FILE         :  RX220_test.c                           */
/*      DESCRIPTION  :  Main Program                           */
/*      CPU SERIES   :  RX200                                  */
/*      CPU TYPE     :  RX220                                  */
/*                                                             */
/*      This file is generated by e2 studio.                   */
/*                                                             */
/***************************************************************/                              

#include "iodefine.h"		//プログラムに必要なファイルを読み込む
#include "xprintf.h"
#include <machine.h>


//LEDポート定義
#define	LED1		PORTA.PODR.BIT.B4
#define	LED2		PORTA.PODR.BIT.B1
#define	LED3		PORTA.PODR.BIT.B0
#define	LED4		PORTA.PODR.BIT.B3
#define	LED5		PORTA.PODR.BIT.B6

//SWポート定義
#define	SW_GREEN		PORT0.PIDR.BIT.B5

//ICS変換基板切り替えポート定義
#define	EN_IN		PORTC.PODR.BIT.B3

//LEDマクロ定義
#define	LED_ON		1
#define	LED_OFF		0

//SWマクロ定義
#define	SW_ON		0
#define	SW_OFF		1

//SCI通信ボーレート
#define	SCI_BITRATE		9600
#define	SCI_BITRATE2 	38400
#define	SCI_BITRATE3 	115200

//プロトタイプ宣言
void init_RX220(void);
void wait_sw_off(void);
void wait_ms(long ms);
void LED_num(char n);
void print_sci(unsigned char data);
void interrupt_1ms(void);
void uart_send_unsignedchar(unsigned char val);
unsigned char receive_sci(void);

void putchar(void);		//サーボ送信用関数
char getchar(int i);		//サーボ受信用関数
int set_pos (unsigned char id, int pos);

void int_scr1_rxi1(void);
void int_scr1_eri1(void);

void int_scr6_txi6(void);
void int_scr6_rxi6(void);
void int_scr6_tei6(void);
void int_scr6_eri6(void);
void sci6_put_start(void);

//音声IC用関数
void play(unsigned char track);
void volume(unsigned char vol);

//コントローラ用関数
void ps3_data(void);

//グローバル変数
unsigned char data2;
static short sci6_error=0;

unsigned char ps3[8]; // 受信用のデータ(コントローラ用)
unsigned char sci6_get_buff[20];
char sci6_get_buff_2[20];
static unsigned char tx[3] = { 0x00, 0x00, 0x00}; // 送信用のデータ
unsigned char rx[3]; // 受信用のデータ
int get_buff_num;
int get_buff_num2;
int r_data_num;

void main(void){		//一番最初に実行する関数
	init_RX220();		//初期設定関数

	//short count = 0;
	//LED_num(1);
	//wait_ms(1000);
	//LED_num(0);

	while(1){
		//xprintf("受信データ=%u %u %u %u %u %u %u %u\n",ps3[0],ps3[1],ps3[2],ps3[3],ps3[4],ps3[5],ps3[6],ps3[7]);
		if(ps3[2] == 0x10){
			//LED_num(2);
			//wait_ms(1000);
			//LED_num(0);
			wait_ms(150);
			xprintf("sankaku\n");
		}
	}

	/*
	while(1){
		set_pos (0, 7500);
		wait_ms(2000);
		set_pos (0, 9500);
		wait_ms(2000);
	}
	*/

}
//---------------------------------------------------------------
//初期設定
//---------------------------------------------------------------
void init_RX220(void){
	//クロック設定
	SYSTEM.PRCR.WORD = 0xa50b;	//レジスタ書き込み許可
	SYSTEM.SCKCR3.BIT.CKSEL = 2;//クロックソースをメインクロック(20MHz)に設定
	SYSTEM.MOSCCR.BYTE = 0;		//メインクロック発振器動作
	for(volatile short i = 0; i < 300; i++);//クロックが安定するまで待つ

	//IOポート初期設定
	PORT.PSRA.BIT.PSEL6 = 0;	//PB6を選択
	PORT.PSRA.BIT.PSEL7 = 0;	//PB7を選択
	PORTA.PDR.BYTE = 0x5b;		//PA0,1,3,4,6(LED)を出力に設定(0101 1011)
	PORTA.PODR.BYTE = 0x00;		//PA0,1,3,4,6(LED)の出力を0にする(0000 0000)
	PORT0.PCR.BIT.B5 = 1;		//P05(タクトスイッチ)の内部プルアップを有効にする

	PORTC.PDR.BIT.B3 = 1;		//PC3を出力に設定
	EN_IN = 0;		//EN_INをL(最初はLにしておく)

	//コンペアマッチタイマ初期設定
	//1ms割り込み用
	MSTP_CMT0 = 0; 				//モジュールストップ解除
	CMT.CMSTR0.BIT.STR0 = 0;	//タイマ停止
	CMT0.CMCR.BIT.CKS = 1;		//動作周波数設定:20MHz／32 = 625kHz
	CMT0.CMCR.BIT.CMIE = 1;		//コンペアマッチで割り込みを許可
	CMT0.CMCNT = 0;				//カウントをクリア
	CMT0.CMCOR = 625-1;			//1ms周期で割り込み	割り込みが発生するのはコンペアマッチした次のカウントタイミングなので1を引く
	IR(CMT0,CMI0) = 0;			//割り込み要求フラグクリア
	IEN(CMT0,CMI0) = 1;			//割り込み要求許可
	IPR(CMT0,CMI0) = 1;			//割り込み優先度設定
	CMT.CMSTR0.BIT.STR0 = 1;	//タイマスタート

	//wait_ms関数用
	MSTP_CMT1 = 0; 				//モジュールストップ解除
	CMT.CMSTR0.BIT.STR1 = 0;	//タイマ停止
	CMT1.CMCR.BIT.CKS = 1;		//動作周波数設定:20MHz／32 = 625kHz

	//SCI初期設定
	unsigned short dummy;

	//別になくても動いた
	/*-------------------------*/
	//PORTB.PDR.BIT.B6=1;		//PB6を出力設定
	//PORTB.PDR.BIT.B7=1;		//PB7を出力設定
	//PORTB.ODR1.BIT.B4=1;		//PB6をオープンドレインに設定
	//PORTB.ODR1.BIT.B6=1;		//PB7をオープンドレインに設定
	//PORTB.PDR.BIT.B0=1;		//PB0を出力設定
	//PORTB.PDR.BIT.B1=1;		//PB1を出力設定
	//PORTB.ODR0.BIT.B0=1;		//PB0をオープンドレインに設定
	//PORTB.ODR0.BIT.B2=1;		//PB1をオープンドレインに設定
	/*-------------------------*/

	//SCI9用
	MSTP_SMCI9 = 0;				//SCI9モジュールスタンバイ解除
	SCI9.SCR.BYTE = 0x00;		//送信,受信及び割り込み要求を禁止
	MPC.PWPR.BIT.B0WI = 0;		//PFSWEビットへの書き込みを許可
	MPC.PWPR.BIT.PFSWE = 1;		//PFSレジスタへの書き込みを許可
	MPC.PB6PFS.BIT.PSEL = 10;	//PB6をRXD9に設定
	MPC.PB7PFS.BIT.PSEL = 10;	//PB7をTXD9に設定
	MPC.PWPR.BIT.PFSWE = 0;		//PFSレジスタへの書き込みを禁止
	MPC.PWPR.BIT.B0WI = 1;		//PFSWEビットへの書き込みを禁止
	PORTB.PMR.BIT.B6 = 1;		//TXD9を周辺モジュール入出力に設定
	PORTB.PMR.BIT.B7 = 1;		//RXD9を周辺モジュール入出力に設定
	SCI9.SCR.BIT.CKE = 0;		//クロック設定
	SCI9.SMR.BYTE = 0x00;		//b0 					0：
								//b1クロック選択ビット			0：PCLKクロック(n=0)
								//b2 マルチプロセッサモードビット	0：マルチプロセッサ通信機能を禁止
								//b3 ストップビット長選択		0：1ストップビット
								//b4 パリティモードビット			0：偶数パリティで送受信
								//b5 パリティ許可ビット			0：パリティビットを付加
								//b6 キャラクタ長ビット			0：データ長8ビットで送受信
								//b7 コミュニケーションモードビット	0：調歩同期式モードで動作

	//(CLOCK)/(64*SCI_BITRATE*2^(2n-1))-1
	long sci_brr;
	sci_brr = (20000000 * 10) / (64 * SCI_BITRATE / 2) - 10;
	sci_brr = (sci_brr + 5) / 10;

	SCI9.BRR = (unsigned char)sci_brr;	//ビットレート調整
	IPR(SCI9,TXI9) = 14;		//割り込み優先度設定
	IPR(SCI9,RXI9) = 14;		//割り込み優先度設定
	IR(SCI9,TXI9) = 0;			//割り込み要求フラグクリア
	IR(SCI9,RXI9) = 0;			//割り込み要求フラグクリア
	for(dummy = 0; dummy < 50000; dummy++);//ちょっと待つ
	SCI9.SCR.BIT.TIE = 1;		//TXI割り込み許可
	SCI9.SCR.BIT.RIE = 1;		//RXI割り込み許可
	SCI9.SCR.BIT.TE = 1;		//送信開始
	SCI9.SCR.BIT.RE = 1;		//受信開始
	dummy = SCI9.SSR.BYTE;		//ダミーリード
	SCI9.SSR.BYTE = 0xC0;		//フラグクリア

	//SCI6用
		MSTP_SMCI6 = 0;				//SCI6モジュールスタンバイ解除
		SCI6.SCR.BYTE = 0x00;		//送信,受信及び割り込み要求を禁止
		MPC.PWPR.BIT.B0WI = 0;		//PFSWEビットへの書き込みを許可
		MPC.PWPR.BIT.PFSWE = 1;		//PFSレジスタへの書き込みを許可
		MPC.PB0PFS.BIT.PSEL = 11;	//PB0をRXD6に設定(ユーザーズマニュアル20.2.9参照)
		MPC.PB1PFS.BIT.PSEL = 11;	//PB1をTXD6に設定
		MPC.PWPR.BIT.PFSWE = 0;		//PFSレジスタへの書き込みを禁止
		MPC.PWPR.BIT.B0WI = 1;		//PFSWEビットへの書き込みを禁止
		PORTB.PMR.BIT.B0 = 1;		//RXD6を周辺モジュール入出力に設定
		PORTB.PMR.BIT.B1 = 1;		//TXD6を周辺モジュール入出力に設定
		SCI6.SCR.BIT.CKE = 0;		//クロック設定
		SCI6.SMR.BYTE = 0x20;		//b0 					0：
									//b1クロック選択ビット			0：PCLKクロック(n=0)
									//b2 マルチプロセッサモードビット	0：マルチプロセッサ通信機能を禁止
									//b3 ストップビット長選択		0：1ストップビット
									//b4 パリティモードビット			0：偶数パリティで送受信
									//b5 パリティ許可ビット			1：パリティビットを付加
									//b6 キャラクタ長ビット			0：データ長8ビットで送受信
									//b7 コミュニケーションモードビット	0：調歩同期式モードで動作
		SCI6.SCMR.BIT.SDIR = 0; 	//初期値
		IPR(SCI6,TXI6) = 15;		//割り込み優先度設定
		IPR(SCI6,RXI6) = 15;		//割り込み優先度設定
		IPR(SCI6,TEI6) = 15;		//割り込み優先度設定
		IPR(SCI6,ERI6) = 15;		//割り込み優先度設定
		IR(SCI6,TXI6) = 0;			//割り込み要求フラグクリア
		IR(SCI6,RXI6) = 0;			//割り込み要求フラグクリア
		IR(SCI6,TEI6) = 0;			//割り込み要求フラグクリア
		IR(SCI6,ERI6) = 0;			//割り込み要求フラグクリア
		IEN(SCI6, TXI6) = 1;		//割り込み許可(これ無いと割り込みしない)
		IEN(SCI6, RXI6) = 1;		//割り込み許可(これ無いと割り込みしない)
		IEN(SCI6, TEI6) = 1;		//割り込み許可(これ無いと割り込みしない)
		IEN(SCI6, ERI6) = 1;		//割り込み許可(これ無いと割り込みしない)

		SCI6.SEMR.BIT.ABCS = 1;		//1syc8bit
		SCI6.SEMR.BIT.NFEN = 1;		//ノイズフィルタ

		//sci_brr = (20000000 * 10) / (64 * SCI_BITRATE3 / 2) - 10;
		//sci_brr = (sci_brr + 5) / 10;
		SCI6.BRR = 10; //115200bpsになるよう調整

		for(dummy = 0; dummy < 50000; dummy++);//ちょっと待つ
		dummy = SCI6.SSR.BYTE;		//ダミーリード
		SCI6.SSR.BYTE |= 0xC0;		//フラグクリア

	//SCI1用
	MSTP_SMCI1 = 0;				//SCI1モジュールスタンバイ解除
	SCI1.SCR.BYTE = 0x00;		//送信,受信及び割り込み要求を禁止
	MPC.PWPR.BIT.B0WI = 0;		//PFSWEビットへの書き込みを許可
	MPC.PWPR.BIT.PFSWE = 1;		//PFSレジスタへの書き込みを許可
	MPC.P26PFS.BIT.PSEL = 10;	//P26をTXD1に設定
	MPC.P30PFS.BIT.PSEL = 10;	//P30をRXD1に設定
	MPC.PWPR.BIT.PFSWE = 0;		//PFSレジスタへの書き込みを禁止
	MPC.PWPR.BIT.B0WI = 1;		//PFSWEビットへの書き込みを禁止
	PORT2.PMR.BIT.B6 = 1;		//TXD1を周辺モジュール入出力に設定
	PORT3.PMR.BIT.B0 = 1;		//RXD1を周辺モジュール入出力に設定
	SCI1.SCR.BIT.CKE = 0;		//クロック設定
	SCI1.SMR.BYTE = 0x00;		//[CKS1:0]b0 					0：
								//b1クロック選択ビット			0：PCLKクロック(n=0)
								//MP b2 マルチプロセッサモードビット	0：マルチプロセッサ通信機能を禁止
								//STOP b3 ストップビット長選択		0：1ストップビット
								//PM b4 パリティモードビット			0：偶数パリティで送受信
								//PE b5 パリティ許可ビット			0：パリティビットを付加
								//CHR b6 キャラクタ長ビット			0：データ長8ビットで送受信
								//CM b7 コミュニケーションモードビット	0：調歩同期式モードで動作

	SCI1.SCMR.BYTE = 0xF2; 		//初期値

	//(CLOCK)/(64*SCI_BITRATE*2^(2n-1))-1
	sci_brr = (20000000 * 10) / (64 * SCI_BITRATE2 / 2) - 10;
	sci_brr = (sci_brr + 5) / 10;

	SCI1.BRR = (unsigned char)sci_brr;	//ビットレート調整
	IPR(SCI1,TXI1) = 15;		//割り込み優先度設定
	IPR(SCI1,RXI1) = 15;		//割り込み優先度設定
	IR(SCI1,TXI1) = 0;			//割り込み要求フラグクリア
	IR(SCI1,RXI1) = 0;			//割り込み要求フラグクリア
	IEN(SCI1, RXI1) = 1;		//割り込み許可(これ無いと割り込みしない)
	for(dummy = 0; dummy < 50000; dummy++);//ちょっと待つ
	SCI1.SCR.BIT.TIE = 1;		//TXI割り込み許可
	SCI1.SCR.BIT.RIE = 1;		//RXI割り込み許可
	SCI1.SCR.BYTE |= 0x30; 		//送信+受信開始
	dummy = SCI1.SSR.BYTE;		//ダミーリード
	SCI1.SSR.BYTE = 0xC0;		//エラーフラグクリア

	xdev_out(print_sci);
}

//---------------------------------------------------------------
//wait処理
//---------------------------------------------------------------
//チャタリング防止処理
void wait_sw_off(void){
	wait_ms(50);	//50ms待つ
	//全てのスイッチがOFFになるまでループして待つ
	while(SW_GREEN == SW_ON);
	wait_ms(50);	//50ms待つ
}

//wait関数
//指定した時間[ms]待つ
void wait_ms(long ms){
	volatile unsigned long count;

	while(ms > 0){
		if(ms > 100){			//100msまでしか1度に計れない
			count = 100;
		}
		else{
			count = ms;
		}
		ms -= 100;
		count = count * 625 - 1;//625は1msあたりのカウント数
		CMT1.CMCNT = 0;
		CMT.CMSTR0.BIT.STR1 = 1;
		while(CMT1.CMCNT < count);
		CMT.CMSTR0.BIT.STR1 = 0;
	}
}

//---------------------------------------------------------------
//ユーザーインターフェース
//---------------------------------------------------------------
//整数を渡すと2進数をLEDで表示
void LED_num(char n){
	n &= 0x0f;

	if((n&0x08) == 0x08){LED1 = LED_ON;}
	else	{LED1 = LED_OFF;}
	if((n&0x04) == 0x04){LED2 = LED_ON;}
	else	{LED2 = LED_OFF;}
	if((n&0x02) == 0x02){LED3 = LED_ON;}
	else	{LED3 = LED_OFF;}
	if((n&0x01) == 0x01){LED4 = LED_ON;}
	else	{LED4 = LED_OFF;}
}

//音楽再生
void play(unsigned char track) {
	unsigned char play[6] = { 0xAA, 0x07, 0x02, 0x00, track, track + 0xB3 };
	for (int i = 0; i < 6; i++) {
		uart_send_unsignedchar(play[i]);
	}
}
void volume(unsigned char vol) {
	unsigned char volume[5] = { 0xAA, 0x13, 0x01, vol, vol + 0xBE };
	for (int i = 0; i < 6; i++) {
		uart_send_unsignedchar(volume[i]);
	}
}

//音声ICにデータを1バイトずつ送信する
void uart_send_unsignedchar(unsigned char val){
	while(!IR(SCI9,TXI9));
	SCI9.TDR = val;						//次に送信する文字をセット
	IR(SCI9,TXI9) = 0;
}

//unsigned char型の文字をSCIで送る関数
void print_sci(unsigned char data){
	while(!IR(SCI1,TXI1));		//0になったらループ抜ける→送信割り込み要求(=1)があるまで待機
	SCI1.TDR = data;			//データを転送
	IR(SCI1,TXI1) = 0;			//割り込み要求フラグクリア
}

//unsigned char型の文字をSCIで受信する関数
unsigned char receive_sci(void){
	while(!IR(SCI1,RXI1));
	SCI1.RDR = data2;			//データを転送
	IR(SCI1,RXI1) = 0;
	return data2;
}

//PS3コントローラーからの信号を格納する関数
void ps3_data(int i) {
}

//割り込みで呼び出す
void int_scr1_rxi1(void){
	setpsw_i();

	ps3[get_buff_num2] = SCI1.RDR;
	get_buff_num2++;
	if(get_buff_num2>=8){
		get_buff_num2=0;
	}


		 /*
		 for(n=0;n<sizeof(sci6_get_buff_2);n++){
			 sci6_get_buff_2[n]=sci6_get_buff[n];
		 }
		 SCI1.SCR.BIT.RIE =0;
		 SCI1.SCR.BIT.RE =0;
		 */
}

//割り込みで呼び出す
void int_scr1_eri1(void) {
	if(SCI1.SSR.BIT.PER == 1){
		SCI1.SSR.BIT.PER=0;///バリティエラーフラグ
	}
	if(SCI1.SSR.BIT.FER==1){
		SCI1.SSR.BIT.FER=0;///フレームエラーフラグ
	}
	if(SCI1.SSR.BIT.ORER== 1){
		SCI1.SSR.BIT.ORER=0;//オーバランエラーフラグ
	}
}


//サーボモータ制御用
int set_pos (unsigned char id, int pos)
{
  int i; // 繰り返し処理のためにつかう変数
  int dat; // 現在位置を計算するための変数

  tx[0] = (unsigned char)(0x80 | id);
  tx[1] = (unsigned char)(pos >> 7 & 0x7F);
  tx[2] = (unsigned char)(pos & 0x7F);

  //sci6_put_start();
  xprintf ("tx[0]=%u,tx[1]=%u,tx[2]=%u \n", tx[0], tx[1],tx[2]);

  EN_IN = 1;	//送信前にH
  for (i = 0; i < 3; i++){
    putchar (); // コマンドを１バイトずつ送信する
  }

  for (i = 0; i < 3; i++){
    rx[i] = getchar (i); // モーターからの返値を受け取り、rxに代入する
  }

  //xprintf ("rx[0]=%u,rx[1]=%u,rx[2]=%u \n", rx[0], rx[1],rx[2]);

  dat = (int)(rx[1] & 0x7F);
  dat = (dat << 7) + (int)rx[2];

  xprintf ("dat =%d \n", dat);

  return dat;
}

//サーボ送信用関数
void putchar(void){

	if((SCI6.SSR.BIT.TEND) != 1)return;		//送信中ならreturn
	SCI6.SCR.BIT.RE =0;						//受信禁止
	//sci6_trance_bit_num=n;
	/*
	MPC.PWPR.BIT.B0WI = 0;		//PFSWEへの書き込み許可
	MPC.PWPR.BIT.PFSWE = 1;		//PFCレジスタへ書き込み許可
	PORTB.PMR.BIT.B0 = 1;		//	0:GPIO 1:周辺機能
	PORTB.PMR.BIT.B1 = 1;
	MPC.PB0PFS.BIT.PSEL = 0;	// RXD6をHi-Zに
	MPC.PB1PFS.BIT.PSEL = 11;	// TXD6
	MPC.PWPR.BIT.PFSWE = 0;		//PFCレジスタへ書き込み禁止
	MPC.PWPR.BIT.B0WI = 1;		//PFSWEへの書き込み禁止
	*/
	SCI6.SCR.BIT.TIE =1;
	SCI6.SCR.BIT.TE =1;	//送信開始
}
//サーボ受信用関数
char getchar(int i){
	return sci6_get_buff_2[i];
}

/*
void sci6_put_start(void){
	PORTB.PMR.BIT.B1=1;				//TXD6を周辺モジュール入出力に設定
	MPC.PB1PFS.BIT.PSEL = 11;		// TXD6
	SCI6.SCR.BIT.TIE=1;
	SCI6.SCR.BIT.TE=1;
}
*/

//割り込みで呼び出す
void int_scr6_txi6(void) {			//TIE=0,TEIE=1にならない限り呼び出され続ける?
	static int i = 0;				//staticをつけることで、最初の1回のみ初期化
	setpsw_i();
	if(i>=3){
		SCI6.SCR.BIT.TIE=0;
		SCI6.SCR.BIT.TEIE=1;
		//PORTC.PODR.BIT.B3 = 0;		//送信終了時L(タイミングが早すぎた?)
		i=0;
	}else{
		SCI6.TDR=tx[i];
		i++;
	}
}

//割り込みで呼び出す
void int_scr6_rxi6(void){
	while((SCI6.SSR.BYTE&0x40)==0){} //受信フラグが1にセットされるのを待つ
	int n;
	setpsw_i();

	sci6_get_buff[get_buff_num] = SCI6.RDR;
	get_buff_num++;

	 if(get_buff_num>=3){
		 get_buff_num=0;

		 for(n=0;n<sizeof(sci6_get_buff_2);n++){
			 sci6_get_buff_2[n]=sci6_get_buff[n];
		 }
		 SCI6.SCR.BIT.RIE =0;
		 SCI6.SCR.BIT.RE =0;
	 }
}

//割り込みで呼び出す
void int_scr6_tei6(void) {

	setpsw_i();					//何のため?
	SCI6.SCR.BIT.TIE=0;
	SCI6.SCR.BIT.TEIE=0;
	SCI6.SCR.BIT.TE=0;
	/*
	PORTB.PMR.BIT.B1=0;			//PB1を汎用入出力に設定
	PORTB.PDR.BIT.B1=1;
	PORTB.PODR.BIT.B1=1;
	MPC.PWPR.BIT.B0WI = 0;		//PFSWEへの書き込み許可
	MPC.PWPR.BIT.PFSWE = 1;		//PFCレジスタへ書き込み許可
	PORTB.PMR.BIT.B0 = 1;		//	0:GPIO 1:周辺機能
	PORTB.PMR.BIT.B1 = 1;
	PORTB.ODR0.BIT.B0=1;		//PB0をオープンドレインに設定
	MPC.PB0PFS.BIT.PSEL = 11;	// RXD6
	MPC.PB1PFS.BIT.PSEL = 0;	// TXD6をHi-Zに
	MPC.PWPR.BIT.PFSWE = 0;		//PFCレジスタへ書き込み禁止
	MPC.PWPR.BIT.B0WI = 1;		//PFSWEへの書き込み禁止
	*/
	PORTC.PODR.BIT.B3 = 0;		//送信終了時L
	SCI6.SCR.BIT.RIE =1;		//受信開始
	SCI6.SCR.BIT.RE =1;			//受信開始
}

//割り込みで呼び出す
void int_scr6_eri6(void) {
	int er=1;

	if(SCI6.SSR.BIT.PER == 1){
		SCI6.SSR.BIT.PER=0;///バリティエラーフラグ
		er=2;
	}
	if(SCI6.SSR.BIT.FER==1){
		SCI6.SSR.BIT.FER=0;///フレームエラーフラグ
		er=3;
	}
	if(SCI6.SSR.BIT.ORER== 1){
		SCI6.SSR.BIT.ORER=0;//オーバランエラーフラグ
		er = 4;
	}

	sci6_error=er;
}


//---------------------------------------------------------------
//タイマ割り込み
//---------------------------------------------------------------
//1ms間隔で実行される関数
void interrupt_1ms(void){
}




